###排序算法总结
|算法|时间复杂度|额外空间复杂度|稳定性
|---|---|---|---|
选择排序|O(N^2)   |O(1)   |无
冒泡排序|O(N^2)   |O(1)   |有
插入排序|O(N^2)   |O(1)   |有
归并排序|O(N*logN)|O(N)   |有
随机快排|O(N*logN)|O(logN)|无
堆排序 |O(N*logN)|O(1)   |无
计数排序|O(N)    |O(N)   |有
基数排序|O(N)    |O(N)   |有

###不基于比较的排序
桶排序思想下的排序：计数排序 和 基数排序
1. 桶排序思想下的排序都是不基于比较的排序
2. 时间复杂度是O(N)，额外空间复杂度是O(M)
3. 应用范围有限，需要样本的数据状况满足桶的划分

###计数排序 和 基数排序
1. 一般来讲，计数排序要求样本是整数，切范围较窄
2. 一般来讲，基数排序要求样本是10
一旦要求稍有升级，改写代价增加是显而易见的。

###排序算法的稳定性
稳定性是指同样大小的样本再次排序后不会改变相对的次序
对基础类型来说，稳定性毫无意义
对非基础类型来说，稳定性有重要意义
有些排序算法可以实现成稳定的，而有些排序算法无论如何都不行

###排序算法总结
1. 不基于比较的排序，对样本数据有严格要求，不易改写
2. 基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
3. 基于比较的排序，时间复杂度的极限是O(N*logN)
4. 时间复杂度O(N*logN)，额外空间复杂度低于O(N)，且稳定的比较的排序是不存在的
5. 为了绝对的速度选快速排序，为了省空间选堆排序，为了稳定性选归并排序

###常见的坑
1. 归并排序的额外空间复杂度可以变成O(1),“归并排序 内部缓存法”，但是将变得不再稳定
2. “原地归并排序”是垃圾帖，会让时间复杂度变成O(N^2)
3. 快速排序稳定性改进，“01 stable sort”,但是会对样本数据要求更多。